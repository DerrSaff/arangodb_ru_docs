extends ../../layout.jade

block title
  title Обход по графу

block sidebar
  include ../../partials/aql-sidebar.jade

block content
  :marked
    # Обход по графу

    Такие отношения, как отношения между родителями и детьми, могут быть смоделированы в виде графа. В ArangoDB, два документа (документы родителя и ребёнка) могут быть связаны документом ребра. Документы рёбер хранятся в коллекциях рёбер и имеют два дополнительных атрибута: _from и _to. Они ссылаются на два любых документа по их ID (_id).

    ## Отношения в коллекции ChildOf
    
    Наши персонажи имеют следующие отношения между родителями и детьми (указаны только имена для лучшего восприятия:

    ```js
      Robb -> Ned
      Sansa -> Ned
      Arya -> Ned
      Bran -> Ned
      Jon -> Ned
      Robb -> Catelyn
      Sansa -> Catelyn
      Arya -> Catelyn
      Bran -> Catelyn
      Jaime -> Tywin
      Cersei -> Tywin
      Tyrion -> Tywin
      Joffrey -> Jaime
      Joffrey -> Cersei
    ```

    Визуализация в виде графа:
  <img src="/images/ChildOf_Graph.png">

  :marked
    ## Создание рёбер

    Чтобы создать необходимые документы рёбер, чтобы сохранить отношения в базе данных, мы можем произвести запрос, который сочетает в себе join-операцию и фильтрацию для соответствия правильных документов персонажей, а после использовать их атрибут _id, чтобы вставить ребро в коллекцию ребёр *ChildOf*.
    
    Для начала, создайте новую коллекцию с именем *ChildOf* и убедитесь, что установили тип коллекции на "**Ребро**" (Edge)

  <img src="/images/ChildOf_Collection_Creation.png">

  :marked
    После запустите следующий запрос:
    
    ```js
    LET data = [
      {
          "parent": { "name": "Ned", "surname": "Stark" },
          "child": { "name": "Robb", "surname": "Stark" }
      }, {
          "parent": { "name": "Ned", "surname": "Stark" },
          "child": { "name": "Sansa", "surname": "Stark" }
      }, {
          "parent": { "name": "Ned", "surname": "Stark" },
          "child": { "name": "Arya", "surname": "Stark" }
      }, {
          "parent": { "name": "Ned", "surname": "Stark" },
          "child": { "name": "Bran", "surname": "Stark" }
      }, {
          "parent": { "name": "Catelyn", "surname": "Stark" },
          "child": { "name": "Robb", "surname": "Stark" }
      }, {
          "parent": { "name": "Catelyn", "surname": "Stark" },
          "child": { "name": "Sansa", "surname": "Stark" }
      }, {
          "parent": { "name": "Catelyn", "surname": "Stark" },
          "child": { "name": "Arya", "surname": "Stark" }
      }, {
          "parent": { "name": "Catelyn", "surname": "Stark" },
          "child": { "name": "Bran", "surname": "Stark" }
      }, {
          "parent": { "name": "Ned", "surname": "Stark" },
          "child": { "name": "Jon", "surname": "Snow" }
      }, {
          "parent": { "name": "Tywin", "surname": "Lannister" },
          "child": { "name": "Jaime", "surname": "Lannister" }
      }, {
          "parent": { "name": "Tywin", "surname": "Lannister" },
          "child": { "name": "Cersei", "surname": "Lannister" }
      }, {
          "parent": { "name": "Tywin", "surname": "Lannister" },
          "child": { "name": "Tyrion", "surname": "Lannister" }
      }, {
          "parent": { "name": "Cersei", "surname": "Lannister" },
          "child": { "name": "Joffrey", "surname": "Baratheon" }
      }, {
          "parent": { "name": "Jaime", "surname": "Lannister" },
          "child": { "name": "Joffrey", "surname": "Baratheon" }
      }
    ]

    FOR rel in data
        LET parentId = FIRST(
            FOR c IN Characters
                FILTER c.name == rel.parent.name
                FILTER c.surname == rel.parent.surname
                LIMIT 1
                RETURN c._id
        )
        LET childId = FIRST(
            FOR c IN Characters
                FILTER c.name == rel.child.name
                FILTER c.surname == rel.child.surname
                LIMIT 1
                RETURN c._id
        )
        FILTER parentId != null AND childId != null
        INSERT { _from: childId, _to: parentId } INTO ChildOf
        RETURN NEW
    ```

    Документы персонажей не имеют ключей, определённых пользователем. Если бы они у них были, это бы позволило нам создавать рёбра легче:
    
    ```js
    INSERT { _from: "Characters/robb", _to: "Characters/ned" } INTO ChildOf
    ```

    Тем не менее создание рёбер программно на основании имён персонажей - это хорошее упражнение. Разберём запрос:

    * Присвойте переменной отношения в виде массива объектов: каждый с атрибутом "родитель" (parent) и "ребёнок" (child), оба с податрибутом имя (name) и фамилия (surname)
    * для каждого элемента в массиве, присвойте отношение переменной *rel* и выполните последующие инструкции:
    * Присвойте результат выражения переменной parentId
        * Получите первый элемент подзапроса (подзапросы заключены в фигурные скобки, но здесь они также являются частью вызова функции)
          * Для каждого документа в коллекции Characters присвойте документ переменной "c"
          * Примените два условия фильтра: имя в документе персонажа должно быть равно имени родителя в *rel* и фамилия также должна быть равно фамилии в данных отношений
          * Остановитесь на первом совпадении 
          * Верните ID документа персонажа (результат подзапроса - это массив с одним элементом, FIRST() принимает этот элемент и присваивает его переменной *parentId*
        * Присвойте результат выражения переменной childId
          * подзапрос используется, чтобы найти документ ребёнка и его ID, аналогично для документа родителя (смотрите выше)
        * Если один из или оба подзапроса не смогли найти соответствие, пропустите текущее отношение, потому что для создания ребра требуются два ID
        * Вставьте новый документ ребра в коллекцию ChildOf, с ребром, ведущим от childId до parentId и без каких-либо иных атрибутов.
        * Возвратите созданный документ грани (опционально)

    ## Обход по графу к родителям

    Теперь, когда грани соединяют документы персонажей (вершины), мы имеем граф, по которому можно найти родителей какого-либо персонажа - или, в терминологии графов, мы хотим начать с вершин и пройти по рёбрам к другим вершинам:

    ```js
    FOR v IN 1..1 OUTBOUND "Characters/2901776" ChildOf
        RETURN v.name
    ```

    Этот FOR-цикл не проводит итерации по коллекции или массиву, он проходит по графу и совершает итерации по по соединённым вершинам, которые удалось найти, с документом вершин, присвоенным переменной (здесь - *v*). Он также может вернуть рёбра, по которым проходит, как и полный путь от начала до конца в виде двух других переменных.

    В запросе выше обход по графу ограничивается минимальной и максимальной глубиной обхода в единицу (как много шагов сделать от начальной вершины) и поиском рёбер только в OUTBOUND-направлении.Наши рёбра указывают от детей к родителям, и родитель находится в одном шаге от ребёнка, поэтому это позволяет нам найти родителей, начиная с детей. "Characters/2901776" - это начальная вершина. Заметьте, что ID документа будет другим у вас, поэтому измените его в соответствии с вашим ID документа, например, Брана Старка.
    
    ```js
    FOR c IN Characters
        FILTER c.name == "Bran"
        RETURN c._id
    ```

    ```js
    [ "Characters/<YourDocumentkey>" ]
    ```

    Вы также можете сочетать этот запрос с обходом по графу напрямую, чтобы легко изменить начальную вершину, изменяя условие фильтра(ов):

    ```js
    FOR c IN Characters
        FILTER c.name == "Bran"
        FOR v IN 1..1 OUTBOUND c ChildOf
            RETURN v.name
    ```

    Начальная вершина сопровождается ChildOf, нашей коллекцией рёбер. Примерный запрос возвращает только имя каждого родителя, чтобы сохранить результат кратким.

    ```js
    [
    "Ned",
    "Catelyn"
    ]

    Тот же результат будет возвращен для Робба, Арьи и Сансы в качестве стартовых вершин. Для Джона Сноу будет только Нед.

    ## Обход по графу к детям

    Мы также можем идти от родителя в обратном направлении (INBOUND) к детям:

    ```js
    FOR c IN Characters
        FILTER c.name == "Ned"
        FOR v IN 1..1 INBOUND c ChildOf
            RETURN v.name
    ```

    ```js
    [
    "Robb",
    "Sansa",
    "Jon",
    "Arya",
    "Bran"
    ]
    ```

    ## Обход по графу к внукам

    Для семьи Ланнистеров у нас есть отношения, которые соединяют родителей с внуками. Давайте изменим глубину обхода, чтобы вернуть внуков, что означает глубину в два шага:

    ```js
    FOR c IN Characters
        FILTER c.name == "Tywin"
        FOR v IN 2..2 INBOUND c ChildOf
            RETURN v.name
    ```
    
    ```js
    [
    "Joffrey",
    "Joffrey"
    ]
    ```

    Это может быть немного неожиданным, но Джоффри вернулся дважды. Однако если вы посмотрите на визуализацию графа, вы можете увидеть, что к Джоффри ведут несколько путей от Тайвина:

  <img src="/images/ChildOf_Graph.png">

  :marked
    ```js
    Tywin <- Jaime <- Joffrey
    Tywin <- Cersei <- Joffrey
    ```

    Чтобы быстро поправить это, измените последнюю строку запроса на RETURN DISTINCT v.name, чтобы вернуть каждое значение только однажды. Учитывайте, что существует настройки обхода по графу, позволяющие избегать дублирующие рёбра с самого начала.

    ## Обход по графу с переменной глубиной

    Чтобы вернуть родителей и более старших предков Джоффри, мы можем идти по рёбрам графа в направлении OUTBOUND и настроить глубину прохода в как минимум один шаг и два как максимум:

    ```js
    FOR c IN Characters
        FILTER c.name == "Joffrey"
        FOR v IN 1..2 OUTBOUND c ChildOf
            RETURN DISTINCT v.name
    ```

    ```js
    [
      "Cersei",
      "Tywin",
      "Jaime"
    ]
    ```

    Если бы у нас были более разветвлённые фамильные древа, для поиска правнуков или других родственников поменять нужно было бы только глубину обхода.
